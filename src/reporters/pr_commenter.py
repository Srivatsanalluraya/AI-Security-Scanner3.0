#!/usr/bin/env python3
"""
pr_commenter.py

Posts an AI-generated summary as a GitHub PR comment.

Features:
- Structured issue format: [Pushed by, Description, Impact, Fix]
- Concise and actionable
- Severity-based formatting (GitHub-safe)
- Robust error handling
"""

import argparse
import os
import requests
import json
from pathlib import Path


# -----------------------------------------------------
# Build Markdown comment body with structured format
# -----------------------------------------------------
def build_comment_body(issues_data: list, pushed_by: str = "", total_count: int = 0) -> str:
    """
    Build PR comment with structured issue format:
    Issue_count: [Pushed by, Issue Description, Issue Potential Impact, Issue Potential Fix]
    """
    if not issues_data:
        return """## ‚úÖ AI Security Scan - No Issues Found

This automated security scan found **no security issues**.

---
üôå *Generated by the AI Vulnerability Scanner*
"""
    
    # Build issue list
    issue_lines = []
    for idx, issue in enumerate(issues_data, start=1):
        pushed = pushed_by or issue.get("pushed_by", "Unknown")
        description = issue.get("description", issue.get("issue", "No description"))[:150]
        impact = issue.get("impact", f"Severity: {issue.get('severity', 'Unknown')}")[:150]
        fix = issue.get("fix", issue.get("ai_fix", "Review and apply best practices"))[:150]
        
        issue_line = f"**Issue #{idx}**: [{pushed} | {description} | {impact} | {fix}]"
        issue_lines.append(issue_line)
    
    issues_section = "\n".join(issue_lines)
    
    comment = f"""## üîç AI Security Scan Summary

**Total Issues Found: {total_count}**

---

{issues_section}

---

### üìå Notes
- Issues are automatically analyzed by Bandit, Semgrep, and pip-audit.
- AI summaries provide concise description, impact, and fix suggestions.
- Please validate findings and apply fixes as needed.

---

üôå *Generated by the AI Vulnerability Scanner*
"""
    return comment


# -----------------------------------------------------
# Post PR comment via GitHub API
# -----------------------------------------------------
def post_comment(repo: str, pr_number: str, token: str, comment: str):
    url = f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments"

    headers = {
        "Authorization": f"Bearer {token}",
        "Accept": "application/vnd.github+json"
    }

    resp = requests.post(url, headers=headers, json={"body": comment})

    if resp.status_code >= 300:
        raise Exception(
            f"GitHub API error: {resp.status_code} {resp.text}"
        )

    print(f"üí¨ Successfully posted PR comment on #{pr_number}")


def post_pr_summary(severity: str, issue_count: int):
    """
    Simple alternative: print summary to stdout for GitHub Actions.
    GitHub Actions can capture this and set output variables.
    """
    print(f"::notice::AI Security Scan: {issue_count} issues found (Severity: {severity})")


def load_issues_from_report(report_path: Path) -> list:
    """Load issues from the final merged report."""
    if not report_path.exists():
        return []
    
    try:
        data = json.loads(report_path.read_text(encoding="utf-8"))
        issues = []
        
        # Extract issues from merged report
        for report_name, report_data in data.get("reports", {}).items():
            if isinstance(report_data, dict):
                # Handle different report formats
                results = report_data.get("results", report_data.get("issues", []))
                if results:
                    for result in results:
                        issues.append({
                            "source": report_name.replace("-report.json", "").title(),
                            "issue": result.get("message", result.get("issue_text", "")),
                            "severity": result.get("severity", result.get("issue_severity", "MEDIUM")),
                            "path": result.get("path", result.get("filename", "")),
                            "line": result.get("line", result.get("line_number", 0))
                        })
        
        return issues
    except Exception as e:
        print(f"Warning: Could not load issues from report: {e}")
        return []


# --- Main ---
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--summary", help="Path to summary.txt (optional)")
    parser.add_argument("--report", help="Path to final report JSON")
    parser.add_argument("--repo", required=True, help="owner/repo")
    parser.add_argument("--pr", required=True, help="Pull request number")
    parser.add_argument("--token", required=False, help="GitHub token")
    parser.add_argument("--pushed-by", default="", help="GitHub username who pushed")

    args = parser.parse_args()

    # GitHub Token (fallback to env)
    token = args.token or os.environ.get("GITHUB_TOKEN")

    if not token:
        raise Exception("‚ùå GitHub token not provided (set GITHUB_TOKEN or use --token).")

    # Load issues from report if available
    issues = []
    if args.report:
        issues = load_issues_from_report(Path(args.report))

    # Build the final comment
    comment_body = build_comment_body(issues, pushed_by=args.pushed_by, total_count=len(issues))

    # Post it
    post_comment(args.repo, args.pr, token, comment_body)


if __name__ == "__main__":
    main()
